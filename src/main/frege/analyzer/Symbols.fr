module punkt0.analyzer.Symbols where
import punkt0.parser.Grammar
import punkt0.Typed
import punkt0.expression.ExpressionF

tagIds :: (WithId a, Typed a) => (Int -> SymbolType) -> Int -> [a] -> (Int, [a])
tagIds symbolType symbol xs = (i' + symbol, xs')
    where
        (i', xs') = foldr (\c (i,cs) -> (i+1, tagId (l-i-1) c : cs)) (0, []) xs
        l = length xs
        tagId i c = setId (Symbol (symbol+i) (symbolType i) (typeOf c) (idOf c)) c

type State s t = s -> t -> (s, t)
type Env r t = r -> (r, t)

createExpressionSymbols :: State Int Expression
createExpressionSymbols symbol expr = cataExpr alg expr symbol where
    alg :: ExpressionF (Env Int Expression) -> (Env Int Expression)
    alg (IdentifierF i pos) symbol = (symbol, Identifier i pos)
    alg (NewF i pos) symbol = (symbol, New i pos)
    alg (LitIntF n pos) symbol =  (symbol, LitInt n pos)
    alg (LitStringF s pos) symbol = (symbol, LitString s pos)
    alg (LitThisF pos) symbol = (symbol, LitThis pos)
    alg (LitNullF pos) symbol = (symbol, LitThis pos)
    alg (LitTrueF pos) symbol = (symbol, LitTrue pos)
    alg (LitFalseF pos) symbol = (symbol, LitFalse pos)
    alg (BinOpF lhs op rhs pos) symbol = let
        (j, lhs') = lhs symbol
        (k, rhs') = rhs j
        in (k, BinOp lhs' op rhs' pos)
    alg (MethodCallF expr name args pos) symbol = let
        (j, expr') = expr symbol
        (k, args') = applyMany j args
        in (k, MethodCall expr' name args' pos)
    alg (NotF expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Not expr' pos)
    alg (BlockF exprs pos) symbol = let
        (j, exprs') = applyMany symbol exprs
        in (j, Block exprs' pos)
    alg (PrintlnF expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Println expr' pos)
    alg (AssignF var expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Assign var expr' pos)
    alg (IfF p body Nothing pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        in (k, If p' body' Nothing pos)
    alg (IfF p body (Just elseBody) pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        (l, elseBody') = elseBody k
        in (l, If p' body' (Just elseBody') pos)
    alg (WhileF p body pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        in (k, While p' body' pos)
    alg (ClosureF free x t expr pos) symbol = error "Should have no closures when generating symbols"
    alg (LambdaF x t expr pos) symbol = let
        (j, expr') = expr symbol
        k = j+1
        in (k, Lambda (Symbol k LambdaSymbol (ttype t) x) t expr' pos)
    where
        applyMany symbol = foldr (\a (i,as) -> let (i', a') = a i in (i', a' : as)) (symbol, [])

symbolManyExprs :: State Int [Expression]
symbolManyExprs symbol exprs = foldr step (symbol, []) exprs
    where
        step e (i, es) = let
            (j, e') = createExpressionSymbols i e
            in (j, e' : es)

createSymbolsVars :: (Int -> SymbolType) -> State Int [VarDeclaration]
createSymbolsVars tagger symbol vars = let
    (j, vars') = tagIds tagger symbol vars
    exprs = fmap (\var -> var.expr) vars'
    (k, exprs') = symbolManyExprs j exprs
    in (k, zipWith (\var expr -> var.{expr=expr}) vars' exprs')

createSymbolsMethod :: State Int MethodDeclaration
createSymbolsMethod symbol (m@MethodDeclaration{args,vars,exprs})
    = (j, m.{args=args',vars=vars',exprs=exprs'})
    where
        (i, args') = tagIds (\l -> LocalSymbol Param (l+1)) symbol args
        a = length args
        (j, vars') = createSymbolsVars (\l -> LocalSymbol LocalVar (a+l+1)) i vars
        (k, exprs') = symbolManyExprs j exprs

createSymbolsClass :: State Int ClassDeclaration
createSymbolsClass symbol (Class name extends vars methods pos)
    = (k, Class name extends vars' methods'' pos)
    where
        className = nameOf name
        (i, vars') = createSymbolsVars (const $ FieldSymbol className) symbol vars
        (j, methods') = tagIds (const $ MethodSymbol className) i methods
        (k, methods'') = createSymbolsNested createSymbolsMethod j methods'
        createClass vs (k,ms) = (k, Class name extends vs ms pos)

createSymbolsNested :: State Int a -> State Int [a]
createSymbolsNested nested symbol xs = createSymbolsNested' symbol xs []
    where
        createSymbolsNested' i [] acc = (i, reverse acc)
        createSymbolsNested' i (c:cs) acc
            = let (i', c') = nested i c
            in createSymbolsNested' i' cs (c':acc)

createSymbolsMain :: State Int MainDeclaration
createSymbolsMain symbol (main@Main{vars}) =
    (j, main.{vars=vars'})
    where
        (j, vars') = createSymbolsVars (\i -> LocalSymbol LocalVar (i+1)) symbol vars

tagMain i (main@Main{name})
    = main.{name=Symbol i ClassSymbol (TClass $ nameOf name) name}

--- | Replace declarations of identifiers with symbols (starting from 0)
createSymbols :: Program -> Program
createSymbols (Program classes main pos)
    = Program classes'' main' pos
    where
        (i, classes') = tagIds (const ClassSymbol) 0 classes
        (j, main') = createSymbolsMain (i+1) (tagMain i main)
        (k, classes'') = createSymbolsNested createSymbolsClass j classes'

