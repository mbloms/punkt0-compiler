module punkt0.analyzer.Symbols where
import punkt0.parser.Grammar
import punkt0.Typed
import punkt0.expression.ExpressionF

tagIds :: (WithId a, Typed a) => (Int -> SymbolType) -> [a] -> State Int [a]
tagIds symbolType xs symbol = (i' + symbol, xs')
    where
        (i', xs') = foldr (\c (i,cs) -> (i+1, tagId (l-i-1) c : cs)) (0, []) xs
        l = length xs
        tagId i c = setId (Symbol (symbol+i) (symbolType i) (typeOf c) (idOf c)) c

type State s t = s -> (s, t)

createExpressionSymbols :: Expression -> State Int Expression
createExpressionSymbols expr symbol = cataExpr alg expr symbol where
    alg :: ExpressionF (State Int Expression) -> (State Int Expression)
    alg (IdentifierF i pos) symbol = (symbol, Identifier i pos)
    alg (NewF i pos) symbol = (symbol, New i pos)
    alg (LitIntF n pos) symbol =  (symbol, LitInt n pos)
    alg (LitStringF s pos) symbol = (symbol, LitString s pos)
    alg (LitThisF pos) symbol = (symbol, LitThis pos)
    alg (LitNullF pos) symbol = (symbol, LitThis pos)
    alg (LitTrueF pos) symbol = (symbol, LitTrue pos)
    alg (LitFalseF pos) symbol = (symbol, LitFalse pos)
    alg (BinOpF lhs op rhs pos) symbol = let
        (j, lhs') = lhs symbol
        (k, rhs') = rhs j
        in (k, BinOp lhs' op rhs' pos)
    alg (MethodCallF expr name args pos) symbol = let
        (j, expr') = expr symbol
        (k, args') = applyMany j args
        in (k, MethodCall expr' name args' pos)
    alg (NotF expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Not expr' pos)
    alg (BlockF exprs pos) symbol = let
        (j, exprs') = applyMany symbol exprs
        in (j, Block exprs' pos)
    alg (PrintlnF expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Println expr' pos)
    alg (AssignF var expr pos) symbol = let
        (j, expr') = expr symbol
        in (j, Assign var expr' pos)
    alg (IfF p body Nothing pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        in (k, If p' body' Nothing pos)
    alg (IfF p body (Just elseBody) pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        (l, elseBody') = elseBody k
        in (l, If p' body' (Just elseBody') pos)
    alg (WhileF p body pos) symbol = let
        (j, p') = p symbol
        (k, body') = body j
        in (k, While p' body' pos)
    alg (ClosureF free x t expr pos) symbol = error "Should have no closures when generating symbols"
    alg (LambdaF x t expr pos) symbol = let
        (j, expr') = expr symbol
        k = j+1
        in (k, Lambda (Symbol k LambdaSymbol (ttype t) x) t expr' pos)
    where
        applyMany symbol = foldr (\a (i,as) -> let (i', a') = a i in (i', a' : as)) (symbol, [])

symbolManyExprs :: [Expression] -> State Int [Expression]
symbolManyExprs exprs symbol = foldr step (symbol, []) exprs
    where
        step e (i, es) = let
            (j, e') = createExpressionSymbols e i
            in (j, e' : es)

createSymbolsVars :: (Int -> SymbolType) -> [VarDeclaration] -> State Int [VarDeclaration]
createSymbolsVars tagger vars symbol = let
    (j, vars') = tagIds tagger vars symbol
    exprs = fmap (\var -> var.expr) vars'
    (k, exprs') = symbolManyExprs exprs j
    in (k, zipWith (\var expr -> var.{expr=expr}) vars' exprs')

createSymbolsMethod :: MethodDeclaration -> State Int MethodDeclaration
createSymbolsMethod (m@MethodDeclaration{args,vars,exprs}) symbol
    = (j, m.{args=args',vars=vars',exprs=exprs'})
    where
        (i, args') = tagIds (\l -> LocalSymbol Param (l+1)) args symbol
        a = length args
        (j, vars') = createSymbolsVars (\l -> LocalSymbol LocalVar (a+l+1)) vars i
        (k, exprs') = symbolManyExprs exprs j

createSymbolsClass :: ClassDeclaration -> State Int ClassDeclaration
createSymbolsClass (Class name extends vars methods pos) symbol
    = (k, Class name extends vars' methods'' pos)
    where
        className = nameOf name
        (i, vars') = createSymbolsVars (const $ FieldSymbol className) vars symbol
        (j, methods') = tagIds (const $ MethodSymbol className) methods i
        (k, methods'') = createSymbolsNested createSymbolsMethod methods' j

createSymbolsNested :: (a -> State Int a) -> [a] -> State Int [a]
createSymbolsNested nested xs symbol = createSymbolsNested' symbol xs []
    where
        createSymbolsNested' i [] acc = (i, reverse acc)
        createSymbolsNested' i (c:cs) acc
            = let (i', c') = nested c i
            in createSymbolsNested' i' cs (c':acc)

createSymbolsMain :: MainDeclaration -> State Int MainDeclaration
createSymbolsMain (main@Main{vars}) symbol =
    (j, main.{vars=vars'})
    where
        (j, vars') = createSymbolsVars (\i -> LocalSymbol LocalVar (i+1)) vars symbol

tagMain (main@Main{name}) i
    = main.{name=Symbol i ClassSymbol (TClass $ nameOf name) name}

--- | Replace declarations of identifiers with symbols (starting from 0)
createSymbols :: Program -> Program
createSymbols (Program classes main pos)
    = Program classes'' main' pos
    where
        (i, classes') = tagIds (const ClassSymbol) classes 0
        (j, main') = createSymbolsMain (tagMain main i) (i+1)
        (k, classes'') = createSymbolsNested createSymbolsClass classes' j

